#!/bin/sh
#
# Small changes that make typical Unix use slightly easier, go here.

#Terminal be pretty one day
export CLICOLOR=1
export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx

# I can think of no reason why this should be a small number
export HISTSIZE=999999999999999999999999
export HISTFILESIZE=999999999999999999999999
export HISTTIMEFORMAT="%d/%m/%y %T "
export HISTCONTROL=ignoreboth

# Use these to colour output
COLOUR_CODE_BLACK='\033[0;30m'
COLOUR_CODE_BLUE='\033[0;34m'
COLOUR_CODE_BROWN='\033[0;33m'
COLOUR_CODE_GRAY='\033[0;37m'
COLOUR_CODE_GREEN='\033[0;32m'
COLOUR_CODE_PURPLE='\033[0;35m'
COLOUR_CODE_RED='\033[0;31m'
COLOUR_CODE_WHITE='\033[1;37m'
COLOUR_CODE_YELLOW='\033[1;33m'
COLOUR_CODE_NC='\033[0m'

# Uses above codes to colour things more easily
# Replacement for echo, first arg is the colour
# Usage:
# echolor yellow "this is a gentle warning"
# echolor red this is a warning
function echolor() {
  upcase=$(echo $1 | awk '{print toupper($0)}')
  code="COLOUR_CODE_$upcase"
  echo -e "${!code}${@:2}${COLOUR_CODE_NC}"
}

# https://stackoverflow.com/a/8574392/5612201
function array_contains() {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

# How  did anyone function without this?
alias diff='colordiff'

# Ruby inline
alias rube="ruby -e"

# unix coin toss
alias toss="rube 'p rand.round.zero? ? :heads : :tails'"

# Stuff I don't want showing up in the git repo
alias rc='sublime ~/.bashrc'

# If there's a .bashrc in the current directory, grab it
function pick_bashrc_if_available(){
  if [[ "$bashrc" != "$PWD" && "$PWD" != "$HOME" && -e .bashrc ]]
  then
    bashrc="$PWD"
    . .bashrc
  fi
}
export PROMPT_COMMAND=pick_bashrc_if_available

# Look up IPs easily
function ip(){
  curl -X GET "https://ipinfo.io/$1"
  echo
}
function lookup(){
  whois $1
  ip $1
}

# Wrapper to fetch env variables.
# It's annoying when a script fails because a var isn't set, since these errors
# are usually silent. This just puts out a warning when accessing an empty var.
#
# Usage:
# var=$(envar VARIABLE_NAME)
function envar() {
  var=${!1}
  if [ -z $var ]; then
    echolor red "WARNING: Env var $1 hasn't been set"
  fi
  echo $var
}

# If you're checking path for something, I suspect
# what you really want to do is copy it somewhere else.
# Let me strip that newline for you.
function path(){
  if [[ $# -eq 0 ]]
  then
    pwd | tee /dev/tty | tr -d '[:space:]' | pbcopy
  else
    realpath $1 | tee /dev/tty | tr -d '[:space:]' | pbcopy
  fi
}

# -.-
alias CD='cd'

# Make dir and cd into it. Looks like gaali but isn't.
function mkcd () { mkdir -p "$@" && cd "$@"; }

# Bash doesn't have a yield, but this is close enough
# Little macro that checks for confirmation before executing something
# Usage:
# echolor "Warning: you are doing dangerous_thing"
# confirm && do_dangerous_thing
function confirm() {
  read -p "Continue? <Y/N> " input
  response=$(echo -n "$input" | awk '{print tolower($0)}')
  if [[ $response != "y" && $response != "yes" ]]
  then
    echo "Lol okay."
    false
  fi
}

# Gently murder the nice apps
function close(){
  if [[ $# -eq 0 ]]
    then echo "Usage: ${FUNCNAME[0]} [PATTERN]"
  elif [[ -n $(pgrep $1) ]]
    then kill $(pgrep $1); echo "Quit $1."
  else
    echo "No instances of $1 open."
  fi
}

# Brutally extinguish all processes that match a pattern
function hunt(){
  if [[ $# -eq 0 ]]
    then echo "Usage: ${FUNCNAME[0]} [PATTERN]"
  elif [[ -n $(pgrep $1) ]]
    then sudo kill -9 $(pgrep $1); echo "$1 has been taken care of."
  else
    echo 'ERROR: No matching processes. What are you hunting?'
  fi
}

# Find out who you want to kill
function wtf() {
  WTF_LIMIT=10
  if [[ $# -eq 1 ]];
  then
    WTF_LIMIT=$1
  fi
  ps ax -o user,pid,%cpu,%mem,tty,start,time,command | sed 1d | sort -nrk 4 | head -n $WTF_LIMIT| cut -c -181
}

# Host directories
alias webserver='python -m SimpleHTTPServer'
